
//  WARNING:
//    This file was autogenerated by h5_to_cpp.py.
//    Do not edit by hand!
//
//    The invocation that generated this file was:
//
//       h5_to_cpp.py -f MiniRun5_1E19_RHC.flow.0000000.flash.larcv_spine.h5 -o DLP_h5_classes -ns cafmaker::types::dlp -d events -cn Event -d reco_interactions -cn Interaction -d reco_particles -cn Particle -d truth_interactions -cn TrueInteraction -d truth_particles -cn TrueParticle -d flashes -cn Flash -d run_info -cn RunInfo -d trigger -cn Trigger
//


#ifndef CAFMAKER_TYPES_DLP_DLP_H5_CLASSES_H
#define CAFMAKER_TYPES_DLP_DLP_H5_CLASSES_H

#include <array>

#include "H5Cpp.h"
#include "readH5/BufferView.h"

namespace cafmaker::types::dlp
{

  // This generic template will be overloaded
  // for every specific type that we create below
  template <typename T>
  H5::CompType BuildCompType();

  
  enum class Shape : int64_t
  {
    kDelta = 3,
    kGhost = 5,
    kLE = 4,
    kMichel = 2,
    kShower = 0,
    kTrack = 1,
    kUnknown = -1,
  };
  
  
  enum class Pid : int64_t
  {
    kElectron = 1,
    kKaon = 5,
    kMuon = 2,
    kPhoton = 0,
    kPion = 3,
    kProton = 4,
    kUnknown = -1,
  };
  
  
  enum class CurrentType : int64_t
  {
    kCC = 0,
    kNC = 1,
    kUnknownCurrent = -1,
  };
  
  
  enum class InteractionMode : int64_t
  {
    kAMNuGamma = 9,
    kCCCOH = 1097,
    kCCDIS = 1091,
    kCCQE = 1001,
    kCCQEHyperon = 1095,
    kCoh = 3,
    kCohElastic = 4,
    kDIS = 2,
    kDiffractive = 11,
    kEM = 12,
    kElectronScattering = 5,
    kGlashowResonance = 8,
    kIMDAnnihilation = 6,
    kInverseBetaDecay = 7,
    kInverseMuDecay = 1099,
    kMEC = 10,
    kMEC2p2h = 1100,
    kNCCOH = 1096,
    kNCDIS = 1092,
    kNCQE = 1002,
    kNuElectronElastic = 1098,
    kNuanceOffset = 1000,
    kQE = 1,
    kResCCNuBarDelta0PiMinus = 1028,
    kResCCNuBarDeltaMinusPiPlus = 1032,
    kResCCNuBarKaon0Lambda0 = 1076,
    kResCCNuBarNeutronEta = 1070,
    kResCCNuBarNeutronPi0Pi0 = 1086,
    kResCCNuBarNeutronPiMinus = 1010,
    kResCCNuBarNeutronPiPlusPiMinus = 1085,
    kResCCNuBarNeutronRho0 = 1048,
    kResCCNuBarNeutronRhoMinus = 1046,
    kResCCNuBarProtonPi0 = 1011,
    kResCCNuBarProtonPi0Pi0 = 1090,
    kResCCNuBarProtonPiMinus = 1012,
    kResCCNuBarSigma0Kaon0 = 1062,
    kResCCNuBarSigmaMinusKaon0 = 1060,
    kResCCNuDelta2PlusPiMinus = 1021,
    kResCCNuDeltaPlusPiPlus = 1017,
    kResCCNuKaonPlusLambda0 = 1073,
    kResCCNuNeutronPi0 = 1004,
    kResCCNuNeutronPiPlus = 1005,
    kResCCNuNeutronRhoPlus = 1041,
    kResCCNuProtonEta = 1067,
    kResCCNuProtonPi0Pi0 = 1080,
    kResCCNuProtonPiPlus = 1003,
    kResCCNuProtonPiPlusPiMinus = 1079,
    kResCCNuProtonRhoPlus = 1039,
    kResCCNuSigmaPlusKaon0 = 1055,
    kResCCNuSigmaPlusKaonPlus = 1053,
    kResNCNuBarNeutronPi0 = 1015,
    kResNCNuBarNeutronPiMinus = 1016,
    kResNCNuBarProtonPi0 = 1013,
    kResNCNuBarProtonPiPlus = 1014,
    kResNCNuNeutronPi0 = 1008,
    kResNCNuNeutronPiMinus = 1009,
    kResNCNuProtonPi0 = 1006,
    kResNCNuProtonPiPlus = 1007,
    kUnUsed1 = 1093,
    kUnUsed2 = 1094,
    kUnknownInteraction = -1,
    kWeakMix = 13,
  };
  
  
  enum class InteractionType : int64_t
  {
    kAMNuGamma = 9,
    kCCCOH = 1097,
    kCCDIS = 1091,
    kCCQE = 1001,
    kCCQEHyperon = 1095,
    kCoh = 3,
    kCohElastic = 4,
    kDIS = 2,
    kDiffractive = 11,
    kEM = 12,
    kElectronScattering = 5,
    kGlashowResonance = 8,
    kIMDAnnihilation = 6,
    kInverseBetaDecay = 7,
    kInverseMuDecay = 1099,
    kMEC = 10,
    kMEC2p2h = 1100,
    kNCCOH = 1096,
    kNCDIS = 1092,
    kNCQE = 1002,
    kNuElectronElastic = 1098,
    kNuanceOffset = 1000,
    kQE = 1,
    kResCCNuBarDelta0PiMinus = 1028,
    kResCCNuBarDeltaMinusPiPlus = 1032,
    kResCCNuBarKaon0Lambda0 = 1076,
    kResCCNuBarNeutronEta = 1070,
    kResCCNuBarNeutronPi0Pi0 = 1086,
    kResCCNuBarNeutronPiMinus = 1010,
    kResCCNuBarNeutronPiPlusPiMinus = 1085,
    kResCCNuBarNeutronRho0 = 1048,
    kResCCNuBarNeutronRhoMinus = 1046,
    kResCCNuBarProtonPi0 = 1011,
    kResCCNuBarProtonPi0Pi0 = 1090,
    kResCCNuBarProtonPiMinus = 1012,
    kResCCNuBarSigma0Kaon0 = 1062,
    kResCCNuBarSigmaMinusKaon0 = 1060,
    kResCCNuDelta2PlusPiMinus = 1021,
    kResCCNuDeltaPlusPiPlus = 1017,
    kResCCNuKaonPlusLambda0 = 1073,
    kResCCNuNeutronPi0 = 1004,
    kResCCNuNeutronPiPlus = 1005,
    kResCCNuNeutronRhoPlus = 1041,
    kResCCNuProtonEta = 1067,
    kResCCNuProtonPi0Pi0 = 1080,
    kResCCNuProtonPiPlus = 1003,
    kResCCNuProtonPiPlusPiMinus = 1079,
    kResCCNuProtonRhoPlus = 1039,
    kResCCNuSigmaPlusKaon0 = 1055,
    kResCCNuSigmaPlusKaonPlus = 1053,
    kResNCNuBarNeutronPi0 = 1015,
    kResNCNuBarNeutronPiMinus = 1016,
    kResNCNuBarProtonPi0 = 1013,
    kResNCNuBarProtonPiPlus = 1014,
    kResNCNuNeutronPi0 = 1008,
    kResNCNuNeutronPiMinus = 1009,
    kResNCNuProtonPi0 = 1006,
    kResNCNuProtonPiPlus = 1007,
    kUnUsed1 = 1093,
    kUnUsed2 = 1094,
    kUnknownInteraction = -1,
    kWeakMix = 13,
  };
  
  struct Event;
  struct Interaction;
  struct Particle;
  struct TrueInteraction;
  struct TrueParticle;
  struct Flash;
  struct RunInfo;
  struct Trigger;
  
  struct Event
  {
    hdset_reg_ref_t depositions_label;
    hdset_reg_ref_t reco_interactions;
    hdset_reg_ref_t depositions;
    hdset_reg_ref_t trigger;
    hdset_reg_ref_t points;
    hdset_reg_ref_t truth_interactions;
    hdset_reg_ref_t run_info;
    hdset_reg_ref_t index;
    hdset_reg_ref_t truth_particles;
    hdset_reg_ref_t meta;
    hdset_reg_ref_t reco_particles;
    hdset_reg_ref_t points_label;
    hdset_reg_ref_t flashes;
    
    void SyncVectors();
    
    template <typename T>
    const hdset_reg_ref_t& GetRef() const
    {
      if constexpr(std::is_same_v<T, Interaction>) return reco_interactions;
      else if(std::is_same_v<T, Trigger>) return trigger;
      else if(std::is_same_v<T, TrueInteraction>) return truth_interactions;
      else if(std::is_same_v<T, RunInfo>) return run_info;
      else if(std::is_same_v<T, TrueParticle>) return truth_particles;
      else if(std::is_same_v<T, Particle>) return reco_particles;
      else if(std::is_same_v<T, Flash>) return flashes;
    }
    
  };
  
  
  struct Interaction
  {
    int64_t id;
    BufferView<int64_t> index;
    int64_t size;
    float depositions_sum;
    BufferView<int64_t> module_ids;
    bool is_contained;
    bool is_matched;
    BufferView<int64_t> match_ids;
    BufferView<float> match_overlaps;
    bool is_cathode_crosser;
    double cathode_offset;
    bool is_truth;
    char * units;
    BufferView<int64_t> particle_ids;
    int64_t num_particles;
    std::array<int64_t, 6> particle_counts;
    std::array<int64_t, 6> primary_particle_counts;
    std::array<float, 3> vertex;
    bool is_fiducial;
    bool is_flash_matched;
    int64_t flash_id;
    double flash_time;
    double flash_total_pe;
    double flash_hypo_pe;
    char * topology;
    
    void SyncVectors();
    
    // note: the following 'handle' objects
    // are used internally by HDF5 to keep track
    // of the memory for variable-length buffers.
    // please use the SyncVectors() method
    // after loading data into the object
    // to fill the corresponding BufferView<>s above,
    // and then use those for access to the data.
    
    hvl_t index_handle;
    hvl_t module_ids_handle;
    hvl_t match_ids_handle;
    hvl_t match_overlaps_handle;
    hvl_t particle_ids_handle;
  };
  
  
  struct Particle
  {
    int64_t id;
    BufferView<int64_t> index;
    int64_t size;
    float depositions_sum;
    BufferView<int64_t> module_ids;
    bool is_contained;
    bool is_matched;
    BufferView<int64_t> match_ids;
    BufferView<float> match_overlaps;
    bool is_cathode_crosser;
    double cathode_offset;
    bool is_truth;
    char * units;
    BufferView<int32_t> fragment_ids;
    int64_t num_fragments;
    int64_t interaction_id;
    Shape shape;
    Pid pid;
    int64_t pdg_code;
    bool is_primary;
    double length;
    std::array<float, 3> start_point;
    std::array<float, 3> end_point;
    std::array<float, 3> start_dir;
    std::array<float, 3> end_dir;
    double ke;
    double calo_ke;
    double csda_ke;
    double mcs_ke;
    std::array<float, 3> momentum;
    float p;
    bool is_valid;
    std::array<float, 6> pid_scores;
    std::array<float, 2> primary_scores;
    BufferView<int32_t> ppn_ids;
    
    void SyncVectors();
    
    // note: the following 'handle' objects
    // are used internally by HDF5 to keep track
    // of the memory for variable-length buffers.
    // please use the SyncVectors() method
    // after loading data into the object
    // to fill the corresponding BufferView<>s above,
    // and then use those for access to the data.
    
    hvl_t index_handle;
    hvl_t module_ids_handle;
    hvl_t match_ids_handle;
    hvl_t match_overlaps_handle;
    hvl_t fragment_ids_handle;
    hvl_t ppn_ids_handle;
  };
  
  
  struct TrueInteraction
  {
    int64_t id;
    BufferView<int64_t> index;
    int64_t size;
    float depositions_sum;
    BufferView<int64_t> module_ids;
    bool is_contained;
    bool is_matched;
    BufferView<int64_t> match_ids;
    BufferView<float> match_overlaps;
    bool is_cathode_crosser;
    double cathode_offset;
    bool is_truth;
    char * units;
    int64_t orig_id;
    float depositions_q_sum;
    BufferView<int64_t> index_adapt;
    int64_t size_adapt;
    float depositions_adapt_sum;
    float depositions_adapt_q_sum;
    BufferView<int64_t> index_g4;
    int64_t depositions_g4_sum;
    BufferView<int64_t> particle_ids;
    int64_t num_particles;
    std::array<int64_t, 6> particle_counts;
    std::array<int64_t, 6> primary_particle_counts;
    std::array<float, 3> vertex;
    bool is_fiducial;
    bool is_flash_matched;
    int64_t flash_id;
    double flash_time;
    double flash_total_pe;
    double flash_hypo_pe;
    char * topology;
    int64_t interaction_id;
    int64_t mct_index;
    int64_t track_id;
    int64_t lepton_track_id;
    int64_t pdg_code;
    int64_t lepton_pdg_code;
    CurrentType current_type;
    InteractionMode interaction_mode;
    InteractionType interaction_type;
    int64_t target;
    int64_t nucleon;
    int64_t quark;
    double energy_init;
    double hadronic_invariant_mass;
    double bjorken_x;
    double inelasticity;
    double momentum_transfer;
    double momentum_transfer_mag;
    double energy_transfer;
    double lepton_p;
    double theta;
    char * creation_process;
    std::array<float, 3> position;
    std::array<float, 3> momentum;
    int64_t nu_id;
    std::array<float, 3> reco_vertex;
    
    void SyncVectors();
    
    // note: the following 'handle' objects
    // are used internally by HDF5 to keep track
    // of the memory for variable-length buffers.
    // please use the SyncVectors() method
    // after loading data into the object
    // to fill the corresponding BufferView<>s above,
    // and then use those for access to the data.
    
    hvl_t index_handle;
    hvl_t module_ids_handle;
    hvl_t match_ids_handle;
    hvl_t match_overlaps_handle;
    hvl_t index_adapt_handle;
    hvl_t index_g4_handle;
    hvl_t particle_ids_handle;
  };
  
  
  struct TrueParticle
  {
    int64_t id;
    BufferView<int64_t> index;
    int64_t size;
    float depositions_sum;
    BufferView<int64_t> module_ids;
    bool is_contained;
    bool is_matched;
    BufferView<int64_t> match_ids;
    BufferView<float> match_overlaps;
    bool is_cathode_crosser;
    double cathode_offset;
    bool is_truth;
    char * units;
    int64_t orig_id;
    float depositions_q_sum;
    BufferView<int64_t> index_adapt;
    int64_t size_adapt;
    float depositions_adapt_sum;
    float depositions_adapt_q_sum;
    BufferView<int64_t> index_g4;
    int64_t depositions_g4_sum;
    BufferView<int32_t> fragment_ids;
    int64_t num_fragments;
    int64_t interaction_id;
    Shape shape;
    Pid pid;
    int64_t pdg_code;
    bool is_primary;
    double length;
    std::array<float, 3> start_point;
    std::array<float, 3> end_point;
    std::array<float, 3> start_dir;
    std::array<float, 3> end_dir;
    double ke;
    double calo_ke;
    double csda_ke;
    double mcs_ke;
    std::array<float, 3> momentum;
    float p;
    bool is_valid;
    int64_t mct_index;
    int64_t mcst_index;
    int64_t gen_id;
    int64_t group_id;
    int64_t nu_id;
    int64_t interaction_primary;
    int64_t group_primary;
    int64_t parent_id;
    BufferView<int64_t> children_id;
    int64_t track_id;
    int64_t parent_track_id;
    int64_t ancestor_track_id;
    int64_t parent_pdg_code;
    int64_t ancestor_pdg_code;
    int64_t num_voxels;
    double energy_init;
    double energy_deposit;
    double distance_travel;
    char * creation_process;
    char * parent_creation_process;
    char * ancestor_creation_process;
    double t;
    double parent_t;
    double ancestor_t;
    std::array<float, 3> position;
    std::array<float, 3> end_position;
    std::array<float, 3> parent_position;
    std::array<float, 3> ancestor_position;
    std::array<float, 3> first_step;
    std::array<float, 3> last_step;
    std::array<float, 3> end_momentum;
    float end_p;
    int64_t orig_interaction_id;
    BufferView<int64_t> children_counts;
    std::array<float, 3> reco_start_dir;
    std::array<float, 3> reco_end_dir;
    
    void SyncVectors();
    
    // note: the following 'handle' objects
    // are used internally by HDF5 to keep track
    // of the memory for variable-length buffers.
    // please use the SyncVectors() method
    // after loading data into the object
    // to fill the corresponding BufferView<>s above,
    // and then use those for access to the data.
    
    hvl_t index_handle;
    hvl_t module_ids_handle;
    hvl_t match_ids_handle;
    hvl_t match_overlaps_handle;
    hvl_t index_adapt_handle;
    hvl_t index_g4_handle;
    hvl_t fragment_ids_handle;
    hvl_t children_id_handle;
    hvl_t children_counts_handle;
  };
  
  
  struct Flash
  {
    int64_t id;
    int64_t frame;
    uint8_t in_beam_frame;
    int64_t on_beam_time;
    double time;
    double time_width;
    double time_abs;
    double total_pe;
    double fast_to_total;
    BufferView<float> pe_per_ch;
    std::array<double, 3> center;
    std::array<double, 3> width;
    char * units;
    
    void SyncVectors();
    
    // note: the following 'handle' objects
    // are used internally by HDF5 to keep track
    // of the memory for variable-length buffers.
    // please use the SyncVectors() method
    // after loading data into the object
    // to fill the corresponding BufferView<>s above,
    // and then use those for access to the data.
    
    hvl_t pe_per_ch_handle;
  };
  
  
  struct RunInfo
  {
    int64_t run;
    int64_t subrun;
    int64_t event;
    
    void SyncVectors();
  };
  
  
  struct Trigger
  {
    int64_t id;
    int64_t time_s;
    int64_t time_ns;
    int64_t beam_time_s;
    int64_t beam_time_ns;
    int64_t type;
    
    void SyncVectors();
  };
  
  
  template <>
  H5::CompType BuildCompType<Event>();
  
  
  template <>
  H5::CompType BuildCompType<Interaction>();
  
  
  template <>
  H5::CompType BuildCompType<Particle>();
  
  
  template <>
  H5::CompType BuildCompType<TrueInteraction>();
  
  
  template <>
  H5::CompType BuildCompType<TrueParticle>();
  
  
  template <>
  H5::CompType BuildCompType<Flash>();
  
  
  template <>
  H5::CompType BuildCompType<RunInfo>();
  
  
  template <>
  H5::CompType BuildCompType<Trigger>();
  

}

#endif // CAFMAKER_TYPES_DLP_DLP_H5_CLASSES_H
